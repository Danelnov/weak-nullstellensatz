import Mathlib
import Mathlib.RingTheory.Ideal.Span

open MvPolynomial
open Ideal
open Classical

public section UPoly

variable {R σ : Type*} [CommRing R]

noncomputable def u_poly (i : σ) (A : Finset R) : MvPolynomial σ R :=
  ∏ a ∈ A, (X i - C a)

def ideal_U (A : Finset R) : Ideal (MvPolynomial σ R) :=
  Ideal.span (Set.range (λ i => u_poly i A))

lemma eval_u_poly {i : σ} {A : Finset R} (x : σ → R)
    (hxA : ∀ (i : σ), x i ∈ A) : (u_poly i A).eval x = 0 := by
  rw [u_poly]
  simp
  have ⟨a, ain, hx⟩: ∃ a ∈ A, x i = a := by aesop
  apply Finset.prod_eq_zero ain
  rw [hx, sub_self]


/-- A polynomial f is in the ideal generated by the u_polys iff f vanishes on all points
    whose coordinates lie in the given finite set A. -/
theorem mem_ideal_U_iff [Fintype σ] [IsDomain R]
    (A : Finset R) (f : MvPolynomial σ R) :
    f ∈ ideal_U A ↔ ∀ (x : σ → R), (∀ (i : σ), x i ∈ A) → f.eval x = 0 := by
  rw [ideal_U, mem_span_range_iff_exists_fun]
  constructor
  . intro h x hxA
    obtain ⟨g, hg⟩ := h
    simp [← hg]
    apply Finset.sum_eq_zero
    intro i hi
    rw [eval_u_poly, mul_zero]
    assumption
  . intro h
    by_cases hA : A = ∅
    . rcases isEmpty_or_nonempty σ with (h1 | h2) <;> simp_all [u_poly]
      . rw [eq_C_of_isEmpty f] at h ⊢
        specialize h (fun _ => 0)
        simp_all
      . obtain ⟨i⟩ := h2
        exists fun j => if j = i then f else 0
        simp_all
    . have := combinatorial_nullstellensatz_exists_linearCombination
        (fun i => A) (fun i => Finset.nonempty_of_ne_empty hA) f h
      obtain ⟨g, h1, h2⟩ := this
      use g
      simp [u_poly]
      simp [Finsupp.linearCombination_apply, Finsupp.sum_fintype] at h2
      exact h2.symm


end UPoly


variable {K σ : Type*} [Field K]  [Fintype σ]
variable (A : Finset K) (I : Ideal (MvPolynomial σ K))

/--
This defines the variety V^A(I) = {x ∈ A^n | p(x) = 0, ∀p ∈ I}.
-/
@[simp]
noncomputable def zeroLocus_on : Finset (σ → K) :=
  {x ∈ Fintype.piFinset fun _ : σ => A | x ∈ zeroLocus K I}



@[simp]
noncomputable def zeroLocus_on_compl : Finset (σ → K) :=
  {x ∈ Fintype.piFinset fun _ : σ => A | x ∉ zeroLocus K I}


variable {A I}

/--
Given an ideal I generated by a finite set of polynomials S (`I = Ideal.span S`),
if a point x lies in `zeroLocus_on_compl A I`, then there exists a generator p ∈ S
that does not vanish at x (i.e., p(x) ≠ 0).
-/
lemma zeroLocus_on_compl_mem
    (x : σ → K) (S : Finset (MvPolynomial σ K)) (hI : I = Ideal.span S) :
    x ∈ zeroLocus_on_compl A I → ∃ p ∈ S, p.eval x ≠ 0 := by
  intro hx
  simp [hI] at hx ⊢
  have ⟨hx, ⟨g, ⟨hg, hgx⟩⟩⟩ := hx
  induction hg using Submodule.span_induction with
  | mem p hp =>
    use p; exact ⟨hp, hgx⟩
  | zero => aesop
  | add p₁ p₂ _ _ ih₁ ih₂ =>
    simp at hgx
    by_cases h : (p₁.eval x) = 0
    . simp [h] at hgx; exact ih₂ hgx
    . exact ih₁ h
  | smul p₁ p₂ _ ih =>
    by_cases h : (p₂.eval x) = 0
    . simp [h] at hgx
    . exact ih h

noncomputable def selector_j
  (S : Finset (MvPolynomial σ K))
  (hI : I = Ideal.span S)
  (x : σ → K)
  (hx : x ∈ zeroLocus_on_compl A I) : MvPolynomial σ K :=
  Classical.choose (zeroLocus_on_compl_mem x S hI hx)

/--
A polynomial constructed to vanish on all points of `zeroLocus_on_compl A I`.
-/
noncomputable def vanishingPolyAux
    (p : MvPolynomial σ K) (S : Finset (MvPolynomial σ K)) (hI : I = Ideal.span S) :=
  p * ∏ b : zeroLocus_on_compl A I,
    let jb := selector_j S hI b b.prop
    (jb - C (jb.eval b))


example [Fintype σ] [Fintype K] (A : Finset K) (I : Ideal (MvPolynomial σ K)) :
    vanishingIdeal K (SetLike.coe $ zeroLocus_on A I) = I + ideal_U A := by
  ext p
  simp [zeroLocus_on, Submodule.mem_sup]
  constructor <;> intro hp
  . sorry
  . intro x hx
    -- Let p = f + g, where f ∈ I and g ∈ ideal_U A
    obtain ⟨f, hf, g, hg, hp⟩ := hp
    rw [← hp, eval_add]
    intro h
    -- as g ∈ ideal_U A, and x ∈ A^n, then g(x) = 0
    -- as f ∈ I, and we supoose h, then f(x) = 0
    simp [(mem_ideal_U_iff A g).mp hg x hx, h f hf]
