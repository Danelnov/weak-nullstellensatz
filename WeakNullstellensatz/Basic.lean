import Mathlib
import Mathlib.RingTheory.Ideal.Span

open MvPolynomial
open Ideal
open Classical

public section UPoly

variable {R σ : Type*} [CommRing R]

noncomputable def u_poly (i : σ) (A : Finset R) : MvPolynomial σ R :=
  ∏ a ∈ A, (X i - C a)

def ideal_U (A : Finset R) : Ideal (MvPolynomial σ R) :=
  Ideal.span (Set.range (λ i => u_poly i A))

lemma eval_u_poly {i : σ} {A : Finset R} (x : σ → R)
    (hxA : ∀ (i : σ), x i ∈ A) : (eval x) (u_poly i A) = 0 := by
  rw [u_poly]
  simp
  have ⟨a, ain, hx⟩: ∃ a ∈ A, x i = a := by aesop
  apply Finset.prod_eq_zero ain
  rw [hx, sub_self]


/-- A polynomial f is in the ideal generated by the u_polys iff f vanishes on all points
    whose coordinates lie in the given finite set A. -/
theorem mem_ideal_U_iff [Fintype σ] [IsDomain R]
    (A : Finset R) (f : MvPolynomial σ R) :
    f ∈ ideal_U A ↔ ∀ (x : σ → R), (∀ (i : σ), x i ∈ A) → f.eval x = 0 := by
  rw [ideal_U, mem_span_range_iff_exists_fun]
  constructor
  . intro h x hxA
    obtain ⟨g, hg⟩ := h
    simp [← hg]
    apply Finset.sum_eq_zero
    intro i hi
    rw [eval_u_poly, mul_zero]
    assumption
  . intro h
    by_cases hA : A = ∅
    . rcases isEmpty_or_nonempty σ with (h1 | h2) <;> simp_all [u_poly]
      . rw [eq_C_of_isEmpty f] at h ⊢
        specialize h (fun _ => 0)
        simp_all
      . obtain ⟨i⟩ := h2
        exists fun j => if j = i then f else 0
        simp_all
    . have := combinatorial_nullstellensatz_exists_linearCombination
        (fun i => A) (fun i => Finset.nonempty_of_ne_empty hA) f h
      obtain ⟨g, h1, h2⟩ := this
      use g
      simp [u_poly]
      simp [Finsupp.linearCombination_apply, Finsupp.sum_fintype] at h2
      exact h2.symm


end UPoly


variable {K σ : Type*} [Field K] (A : Finset K) (I : Ideal (MvPolynomial σ K))


def zeroLocusA : Set (σ → K) :=
  zeroLocus K I ∩ {x : σ → K | ∀ i , x i ∈ A}


def zeroLocusACompl : Set (σ → K) :=
  {x : σ → K | ∀ i, x i ∈ A} \ (zeroLocusA A I)


lemma zeroLocusACompl_mem
    (x : σ → K) (S : Finset (MvPolynomial σ K)) (hI : I = Ideal.span S) :
    x ∈ zeroLocusACompl A I → ∃ p ∈ S, p.eval x ≠ 0 := by
  intro hx
  simp [zeroLocusACompl, zeroLocusA, hI] at hx ⊢
  have ⟨hx, ⟨g, ⟨hg, hgx⟩⟩⟩ := hx
  induction hg using Submodule.span_induction with
  | mem p hp =>
    use p; exact ⟨hp, hgx⟩
  | zero => aesop
  | add p₁ p₂ _ _ ih₁ ih₂ =>
    simp at hgx
    by_cases h : (p₁.eval x) = 0
    . simp [h] at hgx
      exact ih₂ hgx
    . exact ih₁ h
  | smul p₁ p₂ _ ih =>
    by_cases h : (p₂.eval x) = 0
    . simp [h] at hgx
    . exact ih h


example [Fintype σ] [Fintype K] (A : Finset K) (I : Ideal (MvPolynomial σ K)) :
    vanishingIdeal K (zeroLocusA A I) = I + ideal_U A := by
  ext p
  simp [zeroLocusA, Submodule.mem_sup]
  constructor <;> intro hp
  . sorry
  . intro x hx
    obtain ⟨f, hf, g, hg, hp⟩ := hp
    rw [← hp, eval_add]
    simp_all
    apply (mem_ideal_U_iff A g).mp
    exact hg
