import Mathlib.Algebra.MvPolynomial.Basic
import Mathlib.Combinatorics.Nullstellensatz
import Mathlib.RingTheory.Nullstellensatz
import Mathlib.RingTheory.Ideal.Span
import Mathlib.RingTheory.Noetherian.Defs
import Mathlib.Algebra.BigOperators.Group.Finset.Basic

open MvPolynomial
open Classical

public section UPoly

variable {R σ : Type*} [CommRing R]

noncomputable def u_poly (i : σ) (A : Finset R) : MvPolynomial σ R :=
  ∏ a ∈ A, (X i - C a)

def ideal_U (A : Finset R) : Ideal (MvPolynomial σ R) :=
  Ideal.span (Set.range (λ i => u_poly i A))

lemma eval_u_poly {i : σ} {A : Finset R} (x : σ → R)
    (hxA : ∀ (i : σ), x i ∈ A) : (u_poly i A).eval x = 0 := by
  rw [u_poly]
  simp
  have ⟨a, ain, hx⟩: ∃ a ∈ A, x i = a := by aesop
  apply Finset.prod_eq_zero ain
  rw [hx, sub_self]


/-- A polynomial f is in the ideal generated by the u_polys iff f vanishes on all points
    whose coordinates lie in the given finite set A. -/
theorem mem_ideal_U_iff [Fintype σ] [IsDomain R]
    (A : Finset R) (f : MvPolynomial σ R) :
    f ∈ ideal_U A ↔ ∀ (x : σ → R), (∀ (i : σ), x i ∈ A) → f.eval x = 0 := by
  rw [ideal_U, Ideal.mem_span_range_iff_exists_fun]
  constructor
  . intro h x hxA
    obtain ⟨g, hg⟩ := h
    simp [← hg]
    apply Finset.sum_eq_zero
    intro i hi
    rw [eval_u_poly, mul_zero]
    assumption
  . intro h
    by_cases hA : A = ∅
    . rcases isEmpty_or_nonempty σ with (h1 | h2) <;> simp_all [u_poly]
      . rw [eq_C_of_isEmpty f] at h ⊢
        specialize h (fun _ => 0)
        simp_all
      . obtain ⟨i⟩ := h2
        exists fun j => if j = i then f else 0
        simp_all
    . have := combinatorial_nullstellensatz_exists_linearCombination
        (fun i => A) (fun i => Finset.nonempty_of_ne_empty hA) f h
      obtain ⟨g, h1, h2⟩ := this
      use g
      simp [u_poly]
      simp [Finsupp.linearCombination_apply, Finsupp.sum_fintype] at h2
      exact h2.symm


end UPoly


variable {K σ : Type*} [Field K]  [Fintype σ]
variable (A : Finset K) (I : Ideal (MvPolynomial σ K))

/--
This defines the variety V^A(I) = {x ∈ A^n | p(x) = 0, ∀p ∈ I}.
-/
@[simp]
noncomputable def zeroLocus_on : Finset (σ → K) :=
  {x ∈ Fintype.piFinset fun _ : σ => A | x ∈ zeroLocus K I}



@[simp]
noncomputable def zeroLocus_on_compl : Finset (σ → K) :=
  {x ∈ Fintype.piFinset fun _ : σ => A | x ∉ zeroLocus K I}

public noncomputable section vanishingPoly

variable {A I}
variable (S : Finset (MvPolynomial σ K)) (hI : I = Ideal.span S)

include S hI

/--
Given an ideal I generated by a finite set of polynomials S (`I = Ideal.span S`),
if a point x lies in `zeroLocus_on_compl A I`, then there exists a generator p ∈ S
that does not vanish at x (i.e., p(x) ≠ 0).
-/
lemma zeroLocus_on_compl_mem
    (x : σ → K) : x ∈ zeroLocus_on_compl A I → ∃ p ∈ S, p.eval x ≠ 0 := by
  intro hx
  simp [hI] at hx ⊢
  have ⟨hx, ⟨g, ⟨hg, hgx⟩⟩⟩ := hx
  induction hg using Submodule.span_induction with
  | mem p hp =>
    use p; exact ⟨hp, hgx⟩
  | zero => aesop
  | add p₁ p₂ _ _ ih₁ ih₂ =>
    simp at hgx
    by_cases h : (p₁.eval x) = 0
    . simp [h] at hgx; exact ih₂ hgx
    . exact ih₁ h
  | smul p₁ p₂ _ ih =>
    by_cases h : (p₂.eval x) = 0
    . simp [h] at hgx
    . exact ih h

def selector_j
  (x : σ → K)
  (hx : x ∈ zeroLocus_on_compl A I) : MvPolynomial σ K :=
  Classical.choose (zeroLocus_on_compl_mem S hI x hx)

/--
A polynomial constructed to vanish on all points of `zeroLocus_on_compl A I`.
-/
def vanishingPolyAux
    (A : Finset K) : MvPolynomial σ K :=
  ∏ b ∈ (zeroLocus_on_compl A I).attach,
    let jb := selector_j S hI b b.prop
    (jb - C (jb.eval b))

def vanishing_const (A : Finset K) : K :=
  ∏ b ∈ (zeroLocus_on_compl A I).attach, - (selector_j S hI b b.prop).eval b

lemma vanishing_const_nonzero : vanishing_const S hI A ≠ 0 := by
  rw [vanishing_const, Finset.prod_ne_zero_iff]
  intro b _
  have ⟨_, hchoose⟩ := Classical.choose_spec (zeroLocus_on_compl_mem S hI b b.prop)
  simp only [ne_eq, neg_ne_zero, selector_j] at hchoose ⊢
  exact hchoose

lemma vanishingPolyAux_eq_const_add_mem (A : Finset K) :
    ∃ h ∈ I, (vanishingPolyAux S hI A) = C (vanishing_const S hI A) + h := by
  rw [vanishing_const, vanishingPolyAux]
  induction (zeroLocus_on_compl A I).attach using Finset.induction_on with
  | empty => simp
  | insert a B ha ih =>
    -- Let a ∈ zeroLocus_on_compl A I
    -- Let B ⊆ zeroLocus_on_compl A I, such that a ∉ B
    -- Suppose that there exists g ∈ I such that
    -- ∏ b ∈ B, (j_b - j_b(b)) = (∏ b ∈ B, -j_b(b)) + g
    have ⟨g, g_mem, ih⟩ := ih
    let ja := selector_j S hI a a.prop
    let ca : MvPolynomial σ K := C (ja.eval a)
    let c := ∏ b ∈ B, - (selector_j S hI b b.prop).eval b
    use (ja * C c + ja * g - ca * g)
    constructor
    -- The polynomial is in the ideal
    . apply Ideal.sub_mem
      . apply Ideal.add_mem
        . apply Ideal.mul_mem_right
          rw [hI]
          unfold ja selector_j
          have := Classical.choose_spec (zeroLocus_on_compl_mem S hI a a.prop)
          apply Ideal.subset_span
          exact this.1
        . apply Ideal.mul_mem_left
          exact g_mem
      . apply Ideal.mul_mem_left
        exact g_mem
    -- Identity
    . rw [Finset.prod_insert ha, ih, Finset.prod_insert ha]
      grind

end vanishingPoly

theorem vanishingIdeal_zeroLocus_eq_ideal_sum [Fintype K] (A : Finset K) (I : Ideal (MvPolynomial σ K)) :
    vanishingIdeal K (SetLike.coe $ zeroLocus_on A I) = I + ideal_U A := by
  ext p
  simp [zeroLocus_on, Submodule.mem_sup]
  constructor <;> intro hp
  . have ⟨S, hI⟩ := Ideal.fg_of_isNoetherianRing I
    sorry
  . intro x hx
    -- Let p = f + g, where f ∈ I and g ∈ ideal_U A
    obtain ⟨f, hf, g, hg, hp⟩ := hp
    rw [← hp, eval_add]
    intro h
    -- as g ∈ ideal_U A, and x ∈ A^n, then g(x) = 0
    -- as f ∈ I, and we supoose h, then f(x) = 0
    simp [(mem_ideal_U_iff A g).mp hg x hx, h f hf]
