import Mathlib
import Mathlib.RingTheory.Ideal.Span

open MvPolynomial
open Ideal

section UPoly

variable {R σ : Type*} [CommRing R]

noncomputable def u_poly (i : σ) (A : Finset R) : MvPolynomial σ R :=
  ∏ a ∈ A, (X i - C a)

def ideal_U (A : Finset R) : Ideal (MvPolynomial σ R) :=
  Ideal.span (Set.range (λ i => u_poly i A))

lemma eval_u_poly {i : σ} {A : Finset R} (x : σ → R)
    (hxA : ∀ (i : σ), x i ∈ A) : (eval x) (u_poly i A) = 0 := by
  rw [u_poly]
  simp
  have ⟨a, ain, hx⟩: ∃ a ∈ A, x i = a := by aesop
  apply Finset.prod_eq_zero ain
  rw [hx, sub_self]


/-- A polynomial f is in the ideal generated by the u_polys iff f vanishes on all points
    whose coordinates lie in the given finite set A. -/
theorem mem_ideal_U_iff [Fintype σ] [IsDomain R] [DecidableEq σ]
    (A : Finset R) (f : MvPolynomial σ R) :
    f ∈ ideal_U A ↔ ∀ (x : σ → R), (∀ (i : σ), x i ∈ A) → f.eval x = 0 := by
  rw [ideal_U, mem_span_range_iff_exists_fun]
  constructor
  . intro h x hxA
    obtain ⟨g, hg⟩ := h
    simp [← hg]
    apply Finset.sum_eq_zero
    intro i hi
    rw [eval_u_poly, mul_zero]
    assumption
  . intro h
    by_cases hA : A = ∅
    . rcases isEmpty_or_nonempty σ with (h1 | h2) <;> simp_all [u_poly]
      . rw [eq_C_of_isEmpty f] at h ⊢
        specialize h (fun _ => 0)
        simp_all
      . obtain ⟨i⟩ := h2
        exists fun j => if j = i then f else 0
        simp_all
    . have := combinatorial_nullstellensatz_exists_linearCombination
        (fun i => A) (fun i => Finset.nonempty_of_ne_empty hA) f h
      obtain ⟨g, h1, h2⟩ := this
      use g
      simp [u_poly]
      simp [Finsupp.linearCombination_apply, Finsupp.sum_fintype] at h2
      exact h2.symm

end UPoly

section Field

variable {K σ : Type*} [Field K] [Fintype K]

def zeroLocusA (A : Finset K) (I : Ideal (MvPolynomial σ K)) : Set (σ → K) :=
  zeroLocus K I ∩ {x | ∀ i , x i ∈ A}


example (A : Finset K) (I : Ideal (MvPolynomial σ K)) :
    vanishingIdeal K (zeroLocusA A I) = I + ideal_U A := by
  sorry



end Field
